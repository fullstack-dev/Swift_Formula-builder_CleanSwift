//
//  FBProfileTextsViewController.swift
//  FormulaBuilderCS
//
//  Created by PFIdev on 2/11/17.
//  Copyright (c) 2017 orgname. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit
import FZAccordionTableView

protocol FBProfileTextsViewControllerInput {
    func displaySomething(viewModel: FBProfileTexts.Something.ViewModel)
}

protocol FBProfileTextsViewControllerOutput {
    func doSomething(request: FBProfileTexts.Something.Request)
}

class FBProfileTextsViewController: FBProfileBaseViewController {
    var output: FBProfileTextsViewControllerOutput!
    var router: FBProfileTextsRouter!

    @IBOutlet weak var lblTitle: UILabel!
    @IBOutlet weak var tv: FZAccordionTableView!
    @IBOutlet weak var txtFakeForKeyboardDismiss: UITextField!

    var sectionLabels : [String]?
    var tvDataSource: [String: [(String, String, Bool)]]?
    var allEnglishSourceTexts : [String] = ["abc", "bcd", "efg", "fgh"];
    var allChineseSourceTexts : [String] = ["abc", "bcd", "efg", "fgh"];
    
    var englishSourceTextAutoCompleteArray : [String] = [String]()
    var chineseSourceTextAutoCompleteArray : [String] = [String]()
    
    override func awakeFromNib() {
        super.awakeFromNib()
        FBProfileTextsConfigurator.sharedInstance.configure(viewController: self)
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        configureTableView()
        configureTableViewData()
    }
    
    func configureTableView() {
        tv.allowMultipleSectionsOpen = true
        tv.register(UINib(nibName: FBProfileAccordionViewTableHeaderView.kAccordionHeaderViewReuseIdentifier, bundle: nil), forHeaderFooterViewReuseIdentifier: FBProfileAccordionViewTableHeaderView.kAccordionHeaderViewReuseIdentifier)
        tv.register(UINib(nibName: kTextCell, bundle: nil), forCellReuseIdentifier: kTextCell)
        tv.register(UINib(nibName: kTitleCell, bundle: nil), forCellReuseIdentifier: kTitleCell)
    }
    
    func configureTableViewData() {
        sectionLabels = ["Source Texts", "Textual References"]
        
        if (profileMainViewController?.herb != nil) {
            let h = profileMainViewController?.herb
            tvDataSource = [
                "Source Texts": [
                                ("ENGLISH", h!.sourceTextEnglish ?? "", true),
                                ("CHINESE", h!.sourceTextChinese ?? "", false)
                            ],
                "Textual References": []
            ]
        } else if (profileMainViewController?.formula != nil){
            let f = profileMainViewController?.formula
            tvDataSource = [
                "Source Texts": [
                    ("ENGLISH", f!.sourceTextEnglish ?? "", true), /// This should be fixed after english name is defined.
                    ("CHINESE", f!.sourceTextChinese ?? "", false),
                    ("YEAR", f!.textDate ?? "", true),
                    ("AUTHOR", f!.author ?? "", true)
                ],
                "Textual References": []
            ]
        }
        else {
            let a = profileMainViewController?.alternateHerb
            tvDataSource = [
                "Source Texts": [
                    ("ENGLISH", a!.sourceTextEnglish ?? "", true),
                    ("CHINESE", a!.sourceTextChinese ?? "", false),
                    ("YEAR", "", true),
                    ("AUTHOR",  "", true)
                ],
                "Textual References": []
            ]
        }
    }
}

// MARK: UITableViewDelegate
extension FBProfileTextsViewController : UITableViewDelegate, UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        let sectionTitle = sectionLabels![section]
        return tvDataSource![sectionTitle]!.count + (section == 0 ? englishSourceTextAutoCompleteArray.count + chineseSourceTextAutoCompleteArray.count : 0)
    }
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return sectionLabels != nil ? sectionLabels!.count : 0
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        let section = indexPath.section
        let row = indexPath.row
        
        guard section == 0 else {
            return FBTextCell.desiredHeight()
        }
        
        guard row != 0 else {
            return FBTextCell.desiredHeight()
        }
        
        guard row != englishSourceTextAutoCompleteArray.count + 1 else {
            return FBTextCell.desiredHeight()
        }
        
        guard row != englishSourceTextAutoCompleteArray.count + chineseSourceTextAutoCompleteArray.count + 2 else {
            return FBTextCell.desiredHeight()
        }
        
        guard row != englishSourceTextAutoCompleteArray.count + chineseSourceTextAutoCompleteArray.count + 3 else {
            return FBTextCell.desiredHeight()
        }
        
        return 45
    }
    
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return FBProfileAccordionViewTableHeaderView.kDefaultAccordionHeaderViewHeight
    }
    
    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {
        return self.tableView(tableView, heightForRowAt: indexPath)
    }
    
    func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -> CGFloat {
        return self.tableView(tableView, heightForHeaderInSection:section)
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let section : Int = indexPath.section
        let row : Int = indexPath.row
        
        let sectionTitle = sectionLabels![section]
        let sectionValues : [(String, String, Bool)] = tvDataSource![sectionTitle]!
        var resCell : UITableViewCell?
        if (section == 0) {
            if (row == 0) {
                let cell = tableView.dequeueReusableCell(withIdentifier: kTextCell, for: indexPath) as! FBTextCell
                cell.configureTextCell(indexPath: indexPath,
                                       strTitle: sectionValues[0].0,
                                       strSubTitle: sectionValues[0].1,
                                       strPlaceholder: "Add Source Text",
                                       profileType: profileMainViewController!.profileViewType,
                                       isEnglish: sectionValues[0].2)
                cell.cellDelegate = self
                resCell = cell
            } else if (row == englishSourceTextAutoCompleteArray.count + 1) {
                let cell = tableView.dequeueReusableCell(withIdentifier: kTextCell, for: indexPath) as! FBTextCell
                cell.configureTextCell(indexPath: indexPath,
                                       strTitle: sectionValues[1].0,
                                       strSubTitle: sectionValues[1].1,
                                       strPlaceholder: "Add Source Text",
                                       profileType: profileMainViewController!.profileViewType,
                                       isEnglish: sectionValues[1].2)
                cell.cellDelegate = self
                resCell = cell
            } else if (row == englishSourceTextAutoCompleteArray.count + chineseSourceTextAutoCompleteArray.count + 2) {
                let cell = tableView.dequeueReusableCell(withIdentifier: kTextCell, for: indexPath) as! FBTextCell
                cell.configureTextCell(indexPath: indexPath,
                                       strTitle: sectionValues[2].0,
                                       strSubTitle: sectionValues[2].1,
                                       strPlaceholder: "Add Source Text",
                                       profileType: profileMainViewController!.profileViewType,
                                       isEnglish: sectionValues[2].2)
                resCell = cell
            } else if (row == englishSourceTextAutoCompleteArray.count + chineseSourceTextAutoCompleteArray.count + 3) {
                let cell = tableView.dequeueReusableCell(withIdentifier: kTextCell, for: indexPath) as! FBTextCell
                cell.configureTextCell(indexPath: indexPath,
                                       strTitle: sectionValues[3].0,
                                       strSubTitle: sectionValues[3].1,
                                       strPlaceholder: "Add Source Text",
                                       profileType: profileMainViewController!.profileViewType,
                                       isEnglish: sectionValues[3].2)
                resCell = cell
            } else {
                if (englishSourceTextAutoCompleteArray.count > 0 && row > 0 && row < englishSourceTextAutoCompleteArray.count + 1) {
                    let cell = tableView.dequeueReusableCell(withIdentifier: kTitleCell, for: indexPath) as! FBTitleCell
                    cell.configureCell(value: englishSourceTextAutoCompleteArray[row - 1], autoComplete: true)
                    resCell = cell
                } else {
                    let cell = tableView.dequeueReusableCell(withIdentifier: kTitleCell, for: indexPath) as! FBTitleCell
                    cell.configureCell(value: chineseSourceTextAutoCompleteArray[row - englishSourceTextAutoCompleteArray.count - 2], autoComplete: true)
                    resCell = cell
                }
            }
        } else {
            let cell = tableView.dequeueReusableCell(withIdentifier: kTextCell, for: indexPath) as! FBTextCell
            cell.configureTextCell(indexPath: indexPath,
                                   strTitle: sectionValues[row].0,
                                   strSubTitle: sectionValues[row].1,
                                   strPlaceholder: "Add Source Text",
                                   profileType: profileMainViewController!.profileViewType,
                                   isEnglish: sectionValues[row].2)
            resCell = cell
        }
        
        return resCell!
    }
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let accordionView = tableView.dequeueReusableHeaderFooterView(withIdentifier: FBProfileAccordionViewTableHeaderView.kAccordionHeaderViewReuseIdentifier) as! FBProfileAccordionViewTableHeaderView
        accordionView.configureAccordionView(title: sectionLabels![section], isEnabled: self.tableView(tableView, numberOfRowsInSection: section) > 0)
        return accordionView
    }
    
    func tableView(_ tableView: UITableView, shouldHighlightRowAt indexPath: IndexPath) -> Bool {
        let section = indexPath.section
        let row = indexPath.row
        
        guard section == 0 else { return false }
        guard row != 0 && row != englishSourceTextAutoCompleteArray.count + 1 && row != englishSourceTextAutoCompleteArray.count + chineseSourceTextAutoCompleteArray.count + 2 else { return false }
        
        return true
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let section = indexPath.section
        let row = indexPath.row
        
        guard section == 0 else { return }
        guard row != 0 && row != englishSourceTextAutoCompleteArray.count + 1 && row != englishSourceTextAutoCompleteArray.count + chineseSourceTextAutoCompleteArray.count + 2 else { return }
        
        if (englishSourceTextAutoCompleteArray.count > 0 && row > 0 && row < englishSourceTextAutoCompleteArray.count + 1) {
            if (profileMainViewController?.herb != nil) {
                profileMainViewController?.herb!.sourceTextEnglish = englishSourceTextAutoCompleteArray[row - 1]
            } else if (profileMainViewController?.formula != nil){
                profileMainViewController?.formula!.sourceTextEnglish = englishSourceTextAutoCompleteArray[row - 1]
            } else {
                profileMainViewController?.alternateHerb!.sourceTextEnglish = englishSourceTextAutoCompleteArray[row - 1]
            }
            englishSourceTextAutoCompleteArray.removeAll()
        } else {
            if (profileMainViewController?.herb != nil) {
                profileMainViewController?.herb!.sourceTextChinese = chineseSourceTextAutoCompleteArray[row - englishSourceTextAutoCompleteArray.count - 2]
            } else if (profileMainViewController?.formula != nil){
                profileMainViewController?.formula!.sourceTextChinese = chineseSourceTextAutoCompleteArray[row - englishSourceTextAutoCompleteArray.count - 2]
            } else {
                profileMainViewController?.alternateHerb!.sourceTextChinese = chineseSourceTextAutoCompleteArray[row - englishSourceTextAutoCompleteArray.count - 2]
            }
            chineseSourceTextAutoCompleteArray.removeAll()
        }
        
        configureTableViewData()
        tv.reloadData()
    }
}

// MARK: FZAccordionTableViewDelegate
extension FBProfileTextsViewController : FZAccordionTableViewDelegate {
    func tableView(_ tableView: FZAccordionTableView, willOpenSection section: Int, withHeader header: UITableViewHeaderFooterView?) {
        
    }
    
    func tableView(_ tableView: FZAccordionTableView, didOpenSection section: Int, withHeader header: UITableViewHeaderFooterView?) {
        let accordionView = header as! FBProfileAccordionViewTableHeaderView
        accordionView.disclosure_Icon.image = UIImage(named: "arrow_up")
    }
    
    func tableView(_ tableView: FZAccordionTableView, willCloseSection section: Int, withHeader header: UITableViewHeaderFooterView?) {
        
    }
    
    func tableView(_ tableView: FZAccordionTableView, didCloseSection section: Int, withHeader header: UITableViewHeaderFooterView?) {
        let accordionView = header as! FBProfileAccordionViewTableHeaderView
        accordionView.disclosure_Icon.image = UIImage(named: "arrow_down")
    }
    
    func tableView(_ tableView: FZAccordionTableView, canInteractWithHeaderAtSection section: Int) -> Bool {
        return true
    }
}

// MARK: FBProfileTextsViewControllerInput
extension FBProfileTextsViewController : FBProfileTextsViewControllerInput {
    func displaySomething(viewModel: FBProfileTexts.Something.ViewModel) {
        
    }
}

extension FBProfileTextsViewController : FBTextCellDelegate {
    func textFieldBeginEdit(txtField: UITextField, indexPath: IndexPath) {
        self.tv.scrollToRow(at: indexPath, at: .top, animated: false)
    }
    
    func textFieldEditing(txtField: UITextField, indexPath: IndexPath) {
        let row = indexPath.row
        let text = txtField.text!
        let generateAutoCompleteString : ((_ all: [String], _ searchText: String) -> [String]) = { (all : [String]?, s : String) -> [String] in
            guard let autoCompletedValues = all?.filter({ (v) -> Bool in
                return (v.lowercased().range(of: s.lowercased()) != nil)
            }) else {
                return []
            }
            
            return autoCompletedValues.count > 0 ? autoCompletedValues.chunk(5).first! : autoCompletedValues
        }
        
        tvDataSource?.removeAll()
        if (profileMainViewController?.herb != nil) {
            if (row == 0) {
                profileMainViewController?.herb!.sourceTextEnglish = text
                englishSourceTextAutoCompleteArray = generateAutoCompleteString(allEnglishSourceTexts, text)
            } else {
                profileMainViewController?.herb!.sourceTextChinese = text
                chineseSourceTextAutoCompleteArray = generateAutoCompleteString(allChineseSourceTexts, text)
            }
        } else if (profileMainViewController?.formula != nil){
            if (row == 0) {
                profileMainViewController?.formula!.sourceTextEnglish = text
                englishSourceTextAutoCompleteArray = generateAutoCompleteString(allEnglishSourceTexts, text)
            } else {
                profileMainViewController?.formula!.sourceTextChinese = text
                chineseSourceTextAutoCompleteArray = generateAutoCompleteString(allChineseSourceTexts, text)
            }
        } else {
            if (row == 0) {
                profileMainViewController?.alternateHerb!.sourceTextEnglish = text
                englishSourceTextAutoCompleteArray = generateAutoCompleteString(allEnglishSourceTexts, text)
            } else {
                profileMainViewController?.alternateHerb!.sourceTextChinese = text
                chineseSourceTextAutoCompleteArray = generateAutoCompleteString(allChineseSourceTexts, text)
            }
        }
        
        configureTableViewData()
        self.txtFakeForKeyboardDismiss.becomeFirstResponder()
        DispatchQueue.main.async {
            self.tv.reloadData()
        }
        txtField.perform(#selector(becomeFirstResponder), with: nil, afterDelay: 0.01)
    }
    
    func keyboardDismissOnTextCell(txtField: UITextField) {
        
    }
}
